public class SUMMURY {}
/*
절대원칙들
1. 파일(파일, 중활호, 메서드) 하나 안에서 만들어진 것은 다른 파일에서는 못 쓴다.

팁
1. 챗GPT를 잘 이용하자
2. 코드 중심으로 책을 공부하자 ("영어로 Java code example 검색")
   중요순 : 1. 클래스,메서드 2. 상속관련 3. 배열연습 4. 컬렉션과 제네릭
3. 회사는 그 회사만의 코딩룰이 있다
4. 프로그래밍 고인물들은 '확장성'을 굉장히 중요시하기 때문에 초보자들이 보기엔 어려울 수 있다.
   그러나 확장성이 있어야 어떤 곳이던 다양하게 사용할 수 있는 것이다.


엔티티 = 클래스를 데이터베이스에 결합시키는 단계에서는 엔티티라고 부른다.

다 대 다 / 다 대 1 / 1 대 1
Many to many / Many to one / One to one
ex ) 강의:학생 / 강의:교사 / 취준생:이력서

클래스 : 붕어빵 기계
-필드
-메서드
-생성자
가 올 수 있다

메서드 : 붕어빵 기계의 기능
        메서드 사용 이유 : 가독성
생긴 모양 : void 메서드명 ()
          void 메서드명 (매개변수)
          int 메서드명 ()        //int 자리에는 자료명, 변수, 특별한 메서드등이 들어옴
          int 메서드명 (매개변수)        //int 자리에는 자료명, 변수, 특별한 메서드등이 들어옴

생성자 : 클래스 안에 내용 : 붕어빵

게터와 세터 : 게터와 세터는 메서드이다. 필드를 프라이빗으로 하고 세터와 게터로만 접근해 원하는 정보만 필터링 할 수 있다.
사용이유 :
1. 데이터를 안전하게 저장하는 것이다.
2. 내가 만든 필드를 다른 라이브러리에서 호출해서
세터 : 내가 원하는 데이터를 출력 할 수 있다. ex) 이름에는 숫자를 입력할 수 없게 '필터링' 할 수 있다.
게터 : 내가 원하는 데이터를 받을 수 있다. 원하는 정보를 붙여서 줄 수 있음. ex) 내가 2414만 쳐도 2414@gmail.com을 붙여줌




5주차 시험범위 : 컬렉션 5, 제네릭/람다 5
제네릭 문제 : 오브젝트와 무슨 차이와 장점이 있을까?, 선언 방법을 알고 있는것이 중요
장점 1 : 명시성 타입을 확실히 명시해준다.
장점 2 : 타입캐스팅 유무 - 오브젝트는 약한 타입 체크만이 가능해서 에러가 아닌 실행예외가 발생해 프로그램 종료,
그러나 제네릭은 잘못된 케스팅을 할때 문법 오류를 발생시켜 문제를 사전에 예방한다.

컬렉션 문제 : 코드 짜기, 컬렉션의 종류와 기능
형식 : ArrayList<String> str = new ArrayList<>();
str.add("안녕");
List<E> 정보를 저장함
- arraylist 특 : 제네릭 인터페이스로 메모리를 할당해 계속 저장
- Vector 특 : 어레이 리스트의기능을 가지고 있으면서 멀티쓰레드 가능
- LinkedList 특 : 앞뒤 개체의 정보를 저장하는 방식. 중간에 자료가 빠지면 자동 시프트가 가능
Set<E> 중복 정보를 허용하지 않음
- HashSet 특 : 모든 자료를 하나의 주머니에 넣어 관리해서 중복을 없애는 대신에 입력순서와 다르게 출력된다.
- LinkedHashSet 특 : HashSet 의 모든 기능 + 데이터간의 연결 정보로 출력순서가 입력 순서와 동일하다.
- TreeSet 특 : HashSet 의 모든 기능 + 데이터를 크기순으로 출력한다.
Map<K, V> 키와 값을 한 쌍으로 저장하는 컬렉션이다. 키(k)는 중복이 안되며, 값(V)는 중복이 가능하다.
- HashMap 특 : 키는 중복이 안되게 하기때문에 HashSet의 매커니즘과 동일하게 작동하고, 값은 중복이 가능하게 한다.
- HashTable 특 : HashMap과 기능이 똑같으나 멀티쓰레드에 안전하다는 장점
- LinkedHashMap : HashMap의 기본 특성 + 순서대로 데이터가 연결되어 있다.
- TreeMap 특 : 순서와 관계없이 키 값의 크기 순으로 데이터를 저장한다.

람다식 문제 : 메서드의 대표적으로 구성되는 4가지 타입을 람다식으로 변환하기
a1.method1();
A a2 = () -> {System.out.println("입력 X 리턴 X 함수 1");};
*/